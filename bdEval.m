%bdEval  Evaluate the solution of a differential equation.
%   [y,yp] = bdEval(sol,xint,idx) evaluates the solution of the
%   differential equation (sol) at the time points (xint). It is
%   equivalent to the matlab DEVAL function except that it also
%   works for SOL structures generated by third-party solvers.
%   This includes user-defined solvers for the Brain Dynamics toolkit.
%   Like DEVAL, it returns both the values of the solution (y) and
%   its first derivative (yp). The optional idx parameter specifies which
%   rows of the solution (sol.y) to return.
% 
%EXAMPLE
%   sys = ODEdemo1();
%   [sol,solx] = bdSolve(sys,'ode45');
%   tdomain = linspace(sys.tspan(1),sys.tspan(2),100);
%   [y,yp] = bdEval(sol,tdomain);
%   [z,zp] = bdEval(solx,tdomain);
%   figure; plot(tdomain,y, tdomain,z); legend('y','z')
%   figure; plot(tdomain,yp, tdomain,zp); legend('yp','zp')
%
%AUTHORS
%  Stewart Heitmann (2016a)

% Copyright (C) 2016-2018 QIMR Berghofer Medical Research Institute
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
%
% 1. Redistributions of source code must retain the above copyright
%    notice, this list of conditions and the following disclaimer.
% 
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in
%    the documentation and/or other materials provided with the
%    distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
% FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
% COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
% CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
% ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
function [y,yp] = bdEval(sol,xint,idx)
    if ~isstruct(sol) || ~isfield(sol,'x') || ~isfield(sol,'y')
        error('sol is not a valid solver structure');
    end
    
    % number of variables in sol
    n = size(sol.y,1);

    % yindx is an optional argument
    if nargin<3
        idx = 1:n;
    end
    
    % verify the indexes are within bounds
    if any(idx<1) || any(idx>n)
        error('idx is out of bounds');
    end  
    
    switch sol.solver
        case {'ode45','ode23','ode113','ode15s','ide23s','ode23t','ode23tb','dde23'}
            % Use MATLAB deval for MATLAB solvers
            [y,yp] = deval(sol,xint,idx);       
            
        otherwise
            % Use interpolation for third-party solvers.
            % Annoyingly, interp1() transposes the output when the input is
            % a matrix but not a vector. So we treat both cases separately.
            if size(idx,2)==1
                % Here the input is a VECTOR so we DON'T transpose the output.
                y  = interp1(sol.x, sol.y(idx,:)', xint); 
            else
                % Here the input is a MATRIX so we DO transpose the output.
                y  = interp1(sol.x, sol.y(idx,:)', xint)'; 
            end
            
            % Return the gradient vector (if requested)
            if nargout>1
                if isfield(sol,'yp')
                    % The solver has already computed the gradient, so we
                    % only need to interpolate those values.
                    if size(idx,2)==1
                        % Here the input is a VECTOR so we DON'T transpose the output.
                        yp = interp1(sol.x, sol.yp(idx,:)', xint);
                    else
                        % Here the input is a MATRIX so we DO transpose the output.
                        yp = interp1(sol.x, sol.yp(idx,:)', xint)'; 
                    end
                else
                    % Compute the gradient from scratch
                    dt = sol.x(2)-sol.x(1);
                    yp = gradient(sol.y(idx,:),dt);
                end
            end
    end
end

